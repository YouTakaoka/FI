# はじめに
## 基本的な用語
- **疑似言語**: 基本情報技術者試験で出題用に用いられる、独自の言語
- **コード**: プログラミング言語(や疑似言語)で書かれたプログラムのこと

## 記法について
説明の都合上、この文書では次のように約束する:

- `こんな感じ`に背景色が変わってる部分は、コード(の一部)を表す
- コード中で`${...}`と書いたらそこに適切なものが入るとする
  - 例えば、`${変数名}`と書いてあったらそこに適切な変数名(`a`とか)が入る

# Python文法の基本事項
## インデント(字下げ)について
**インデント**(または**字下げ**)とは、プログラム行の始まりに複数個のスペースを入れること。

- Pythonでは通常、スペース4つで一段のインデントを表す
- Pythonではインデントが文法上の意味をもつ
- 同じインデントの高さの行のまとまりを**ブロック**という

例えば、典型的なPythonの制御構文(`if`や`for`など)は次のような形をしている:

```python
${制御構文名} ...:
    ...
    # ここは制御構文の中
    ...

# ここは制御構文の外
```

この場合、

- コロン(`:`)に続くブロックが制御構文の「中身」とみなされる
- インデントが終わったところがブロックの終わり
- ブロックを抜けたら制御構文の外

## 対話コンソールについて
Pythonがインストールされた環境において、WindowsのコマンドプロンプトやPowerShellのようなターミナルソフト上で`py`と入力すると、Pythonの「対話コンソール」が起動する。例えば、コマンドプロンプトでは次のような画面になるはずだ:

```
C:\Users\ideal>py
Python 3.12.1 (tags/v3.12.1:2305ca5, Dec  7 2023, 22:03:25) [MSC v.1937 64 bit (AMD64)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>>
```

この`>>>`と出てる行が**プロンプト**と呼ばれ、ここにPythonの式を入力すると一行ずつ実行することができる。学習用にとても便利である。文法のことで何か分からなくなったらすぐにこの対話コンソールを立ち上げて、自分が今書いている式がどんな値を返すか確認する癖をつけよう。

> (注意)
> 何かの式や値をコンソールに入力したときの出力は、同じ値をPythonプログラム中で`print()`関数に渡したときの出力と同じであり、それはそのオブジェクト(値)を「なんかいい感じ」に整形した文字列である。そしてその「なんかいい感じ」に整形する方法は、そのオブジェクトが属するクラスの定義で決められている。よって、それぞれの値を「どんな風に」見せてくれるかはクラスによってまちまちであり、人間にとって見やすいものもあれば、見づらいものもある。

# 文法のまとめ
- 条件分岐や繰り返しなどの制御構文に関しては、表だけで書ききれないので後ろの補足も参照

|           | Python | 疑似言語 |
| ----      | ----   | ----     |
| 未定義の値 | `None` | `未定義の値` |
| 変数への代入 | `${変数名} = ${値または式}` | `${変数名} <- ${値または式}` |
| (例) 変数`a`に値`3`を代入する | `a = 3` | `a <- 3` |
| 変数の宣言 | `${変数名}: ${型}` | `${型}: ${変数名}` (※順番注意！) |
| (例) 整数型の変数`a`を宣言する | `a: int` | `整数型: a` |
| 条件分岐 | `if ${条件式0}:` ~  `elif ${条件式1}:` ~ `elif ${条件式N}:` ~ `else:` | `if (${条件式0})` ~  `elseif (${条件式})` ~ `elseif (${条件式N})` ~ `else` ~ `endif` |
| 繰り返し(決まった回数) | `for ${変数名} in ${リスト(またはイテラブル)}:` | `for (${変数名} を ${初期値} から ${終了値} まで ${ステップ} ずつ ${増や/減ら}す)` ~ `endfor` |
| 繰り返し(条件による) | `while ${条件式}:` | `while (${条件式})` ~ `endwhile` |
| コメント(一行) | `# ${コメント}` (※行末でも可) | `// ${コメント}` (※行末でも可) |
| (例) (変数`pi`に値`3.14`を代入する行への)「円周率」というコメント | `pi = 3.14  # 円周率` | `pi <- 3.14  // 円周率` |

## 条件分岐(if文)
### 書式(Python)
```python
if ${条件式0}:
    # 条件式0が真だったときの処理
    ${ブロック0}
elif ${条件式1}:
    # 条件式0が偽かつ、条件式1が真だったときの処理
    ${ブロック1}
...
elif ${条件式N}:
    # 条件式1,...,条件式N-1がすべて偽かつ、
    # 条件式Nが真だったときの処理
    ${ブロックN}
else:
    # 条件式1,...,条件式Nがすべて偽だったときの処理
    ${ブロック(デフォルト)}
```

注意点:

- 各節の条件式の終わりにはコロン(`:`)が必要
- 各節の終わりはインデント(字下げ)で区別する

### 書式(疑似言語)
```php
if (${条件式0})
    // 条件式0が真だったときの処理
    ${ブロック0}
elseif (${条件式1})
    // 条件式0が偽かつ、条件式1が真だったときの処理
    ${ブロック1}
...
elseif (${条件式N})
    // 条件式1,...,条件式N-1がすべて偽かつ、
    // 条件式Nが真だったときの処理
    ${ブロックN}
else
    // 条件式1,...,条件式Nがすべて偽だったときの処理
    ${ブロック(デフォルト)}
endif
```

注意点:

- 条件式は括弧`(...)`で囲う必要がある
- 条件式の後ろにコロン(`:`)は不要
- 構文の終わりには`endif`が必要(Pythonと違ってインデントでブロックを識別しているのではないため)

### 全般的な注意点
- `elseif`節(Pythonでいう`elif`節)は省略可能
- `else`節は省略可能

## 条件による繰り返し(while文)
### 書式(Pythonのwhile)
```python
while ${条件式}:
    # ${条件式} が真である限り、以下のブロックが繰り返し実行される
    ${繰り返しブロック}
```

注意点:

- 条件式の終わりにはコロン(`:`)が必要
- 繰り返しブロックの終わりはインデント(字下げ)で区別する

### 書式(疑似言語のwhile)
```php
while (${条件式})
    # ${条件式} が真である限り、以下のブロックが繰り返し実行される
    ${繰り返しブロック}
endwhile
```

注意点:

- 条件式は括弧`(...)`で囲う必要がある
- 条件式の後ろにコロン(`:`)は不要
- 構文の終わりには`endwhile`が必要(Pythonと違ってインデントでブロックを識別しているのではないため)

### 書式(疑似言語のdo-while(do文))
疑似言語には、`while`文の変種である`do`文が存在する(他の多くのプログラミング言語にもあるが、**Pythonにはない**)。

```php
do
    # ${条件式} が真である限り、以下のブロックが繰り返し実行される
    ${繰り返しブロック}
while (${条件式})
```

`while`文との根本的な違いは、`${条件式}`が最初に評価されるタイミングである。`while`文では、 **構文が始まった直後**に1度目の`${条件式}`の評価が行われるが、`do`文では`${繰り返しブロック}`を**一度実行した後に**初めて`${条件式}`が評価される。結果として、次のような差が生じる:

- `while`文: `${条件式}`の真偽によっては、`${繰り返しブロック}`が一度も実行されずに(何もせずに)終了することもある
- `do`文: `${繰り返しブロック}`が(`${条件式}`の真偽に関係なく)少なくとも一回は実行される

### do文の存在意義とかの話
まず、疑似言語(やその他の言語)における`do`文の存在意義をはっきりさせておこう。ひとことで言うと、`do`文が存在するのは単に**便利だから**である。それ以上の理由はない。特に、決して、「`do`文でなければ表現できないもの」があるからでは**ない**。`do`文がなくとも、`while`文さえあれば論理的には事足りる。実際、疑似言語の

```php
do
    ${something}
while (${expr})
```

というコードは、同じく疑似言語の

```php
${something}

while (${expr})
    ${something}
endwhile
```

という(意味上は)**完全に等価**な(そして`do`文を使わない)コードに書き換えられる。つまり、`do`文は`while`文で**常に代用可能**なのだ。

しかし、2つ目のコードには問題もある。全く同じ`${something}`というコードの集まりを2回も書いてしまっている点である。これはプログラミングの重要な考え方の一つである、**OAOO原則**に反している。"OAOO"とは"Once And Only Once"(訳:「一度かつ一度きり」)の略で、平たく言うと「同じことを何度も書くな」という意味の言葉だ。これは何も、ただ「美しくないから」とかそういう美意識だけの話ではない。上記の例で言うと、`${something}`の中身が簡単な関数呼び出しの式(`f(...)`みたいなやつ)とかだったらまだ良いが、場合によってはめっちゃ沢山の行から成る、なんかやべー複雑なコードだったりするかもしれない。そんなのが何か所にも散らばってコピペされてるようなコードは単純に読みづらいし、実務だとメンテナンスも大変になる。そして何よりも致命的なのは、そのコピペされてる箇所を変更する必要が生じた場合である。その時は当然、同じ内容の「コピー」全てを修正しなければならない。しかし、苦労して書き溜めた長い長いコードの中で、例えば自分が1ヶ月前に書いた部分の「コピー」が何か所、それぞれどこに散らばっているかなんて簡単に思い出せるだろうか？　もっと言えば、そもそも変更を行う担当者が、元のコードを書いた本人だとも限らない。そうなったら絶望的である。そんなことを至る所でやるようなコードの書き方が、バグの温床になるのは容易に想像できるであろう。

話が長くなってしまったが、要するに`do`文の存在意義は「プログラマに**同じコードを何度も書かせない**こと」だと考えるのが自然だ。しかし、では何故Pythonには`do`文がないのだろう？　この理由は、(筆者の推測だが)次の2点に集約されると思われる:

1. `do-while`のような構文を、Python文法の「スタイル」に合わせて用意するのが難しい
1. そもそも、`do`文がなくてもOAOO原則を守ったコードは書ける

まず1について。Pythonの文法では、以下のように「構文の終了位置をインデントで識別する」(インデントブロックが終わったところが構文の終わり)のが基本である:

```python
${構文の開始部分(条件等の記述)}:
    ...
    # 構文の中
    ...

# ここから構文の外
```

故に、`do`文のように構造上「構文の終わりに条件等を記述する」ような構文とは相性が悪い。また、こういう設計にしたのはそもそも「構文の終わりに条件部分が来るのは可読性的にどうなのか」という感覚も背後にありそうである。

次に2について。以下に、`do`文を使ったものと等価なコードを列挙しよう。まずは、OAOO原則に反したコード:

```python
""" !!! 絶対に真似しないでね !!! """
${something}

while ${expr}:
    ${something}
```

これを書き換える方法はいくつかある:

```python
""" フラグ変数を使う方法 """

# 初回のループであることを表すフラグ
first_loop: bool = True  # 最初だけ True

while ${expr} or first_loop:
    ${something}
    first_loop = False # ループの終わりに False を設定
```

- 初回の条件評価をフラグで無理やり通過させるイメージ
- 条件部分がちょっと見づらい

```python
""" 継続条件の真偽そのものを変数で管理する方法 """

# 継続条件の真偽を格納する変数
cond: bool = True  # 初期値は True

while cond:
    ${something}
    cond = ${expr} # ここで条件式の値を代入する
```

- 実質的に、ブロックの終わりで条件評価を行っているのと等価になる
- 構文の最後に条件式が来るので、もともとの`do`文と見た目が近い

```python
""" break を使う方法 """

while True:
    ${something}
    if not ${expr}:
        # 条件式の値が偽ならループを抜け出す
        break
```

- 余計な変数を使わなくてよい
- どれが継続条件かがぱっと見分かりにくいかもしれない

## 決まった回数の繰り返し(for文)
### 書式(Pythonのfor)
```python
for ${変数名} in ${リスト(またはイテラブル)}:
    # ${変数名} で指定した変数にリストの要素が順番に代入され、以下のブロックが実行される
    ${繰り返しブロック}
```

例えば、

```python
for i in [x1, x2, ..., xN]:
    ${something}
```

のようなコードは次と等価である:

```python
i = x1
${something}

i = x2
${something}

...

i = xN
${something}
```

### 書式(疑似言語のfor)
```php
for (${変数名} を ${初期値} から ${終了値} まで ${ステップ} ずつ ${増や/減ら}す)
    // ${変数名} で指定した変数に、${初期値} から ${終了値} までの整数値が
    // ${ステップ} ずつ ${増や/減ら} しながら代入され、以下のブロックが実行される
    ${繰り返しブロック}
endfor
```

ただし、

- `${ステップ}`は正の整数
- `${初期値}`と`${終了値}`はいずれも整数
- `${増や/減ら}`の部分は、
    - `${初期値} < ${終了値}` なら `増や`
    - `${初期値} > ${終了値}` なら `減ら`

例えば、

```php
// 変数 b, e, s はここより前で適当に定義されているとする
整数型: i

for (i を b から e まで s ずつ 増やす)
    ${something}
endfor
```

のようなコードは次と等価である:

```php
// 変数 b, e, s はここより前で適当に定義されているとする
整数型: i

i <- b
while (i <= e)  // 「減らす」の場合ここの条件式は `i >= e`
    ${something}
    i <- i + s  // 「減らす」の場合ここの右辺は `i - s`
endwhile
```

### 疑似言語からPythonへの翻訳
Pythonの組み込み関数`range()`を使う。

例えば、疑似言語コードの

```
for (i を 0 から n まで 1 ずつ増やす)
    ${something}
endfor
```

は次のPythonコードと等価である:

```python
for i in range(n + 1):
    ${something}
```

なぜこれでうまくいくのか説明しよう。`range()`関数は、引数に与えた整数値に応じて「リストっぽいもの」を生成してくれる関数である。例えば、Pythonの対話コンソールで

```python
>>> list(range(5))
```

と入力してみてほしい。次のような出力が得られるはずだ:

```
[0, 1, 2, 3, 4]
```

これは、`range(5)`という式が`[0, 1, 2, 3, 4]`というリスト(っぽいもの)を生成したことによる。

ちなみに、`range(5)`を`list(...)`(これは`list`クラスのコンストラクタ)の中に入れているのは、`range()`関数の戻り値が本当の意味での「リスト」ではない(「`range`オブジェクト」というイテラブルの一種)ため、そのままコンソールに入力しても上のように「中身」が見える形で出力されないからである。実際、試しに対話コンソールで

```python
>>> range(5)
```

と入力してみよう。今度は

```
range(0, 5)
```

のような出力になってしまったであろう。対話コンソール上で「中身」を確認したり、プログラム中で`print()`で出力したい場合は、上記のようにしてリストに変換しなくてはならないのだ。ただし、`for`文で使う分にはその必要はない。`range()`関数が返すオブジェクトをそのまま`for`文に渡せば、あとはPythonが内部でよしなにやってくれる。言い換えれば、次のようなコードは(間違いではないが)冗長である:

```python
""" ！！！ 真似しないでね ！！！ """
for i in list(range(n + 1)):
    ${something}
```

ここで`range()`関数の仕様を簡単に説明する:

- `range(n)`: リスト(※)`[0, 1, ..., n-1]`を生成する

(※) 正確に言うと「リスト」ではなく「`range`オブジェクト」というイテラブルの一種だが、ここでは簡単のため「リスト」と表記した。

> (注意)
> 厳密に言うと、`range()`自体も関数ではなく、`range`クラスのコンストラクタである。

> (参考)イテラブル
>
> **イテラブル**とは、「反復可能(iterable)オブジェクト」と呼ばれるもので、簡単に言えば「モノを一列に並べた」構造の総称である。もう少し正確に言うなら、「はじめから順番に、要素をひとつずつ**繰り返し**(**iteratively**)取り出せる」ようなオブジェクトのこと。例えば、リストや文字列、`range`オブジェクトなどがその例である。

# 疑似言語とPythonの注意すべき相違点
|    | Python | 疑似言語 |
|----|----    |----     |
| 配列(リスト)のインデックス | `0`始まり | `0`から始まる場合と`1`から始まる場合がある(公式で仕様が決まっておらず、問題毎に指定がある) |
| 「未定義の値」の扱い | 値`None`は同名の型`None`(および`None`とのUnion型)にのみ属する | `未定義の値`はすべての型に属する |
| 「未定義の値」の扱い(つづき) | 従って、`None` 型(もしくは `None` とのUnion型)以外の変数に `None` 値を格納することはできない | 従って、どんな変数にも `未定義の値` を格納することができる |
| (上の例) 「整数型」の変数に「未定義の値」を格納することができるか？ | No (例えば `a: int = None` はエラー) | Yes (例えば `整数型: a <- 未定義の値` はOK) |

## 「未定義の値」を使うプログラムの翻訳の仕方
例えば、次のような疑似言語のプログラムを考える:

```
整数型: a <- 未定義の値
```

これを「そのまま」Pythonに翻訳して次のようにすると、エラーになる:

```python
a: int = None  # エラー！
```

これは、Pythonでは`int`型の変数に`None`を格納できないからである。上のようなことがやりたければ、変数`a`の型として`None`値を許容するように宣言しておく必要がある:

```python
a: int | None = None  # OK
```

# Pythonの特殊文法まとめ
## 型の演算

| 演算名 | 書式 | 意味 | 例 |
|----   |----  |----  |----|
| Union | `型1 \| 型2` | `型1`または`型2` | `int \| None` (整数型または未定義)

## None値の判定
`None`値の判定において、等値演算子`==`を使うのはあまり良くないとされている(理由は細かいので後述)。

正しくは`is`演算子(および`is not`演算子)を使う。書式:

```python
""" ${expr} を値または式とする。 """

# ${expr} の(値)が None なら True, さもなくば False
${expr} is None

# ${expr} の(値)が None なら False, さもなくば True
${expr} is not None
```

簡単な例:

```python
if a is None:
    # a が None だった場合の処理

if b is not None:
    # b が None でなかった場合の処理
```

もうちょっと高度な例:

```python
def is_not_None(x: int | None) -> bool:
    """ x が None でないか判定
    パラメータ:
        x: 整数または None 値
    戻り値:
        True  (x が None でない(つまり整数))
        False (x が None)
    """
    return x is not None

print(is_not_None(3))    # True
print(is_not_None(None)) # False
```

実践的な例:

```python
# 例えばこんな関数があったとする:
def get_first_even_number(ls: list[int]) -> int | None:
    """ リスト ls の中で最初の偶数を返す(もし ls が偶数を含まなければ None を返す)
    """
    # 以下、参考のために関数の実装も書いておく。
    # が、この例では関数自体の意味が分かれば問題ないので、
    # 関数定義(このブロック)の終わりまでは読み飛ばしてもよい。

    for n in ls:
        # リスト ls の各要素を最初から順に評価
        if n % 2 == 0:
            # もし n が偶数なら、n を返して終了
            return n
    
    # ここまで来たということは ls が偶数を含まなかったということなので、None を返す
    return None

# なんかテキトーなリスト
today: list[int] = [1, 1, 1, 7]

"""
リスト today が偶数を含むなら「今日のあなたのラッキーナンバーは ${最初の偶数} です！やったね！」を、
そうでなければ「あなたは今日一日踏んだり蹴ったりです！m9(^Д^)ﾌﾟｷﾞｬｰ」を出力してみよう。
"""

# まずは、上で定義した関数 get_first_even_number にリスト today を渡して呼び出す
# 呼び出した結果は一旦テキトーな変数 tmp に格納
tmp: int | None = get_first_even_number(today)

if tmp is not None:
    # today が偶数を含む場合
    print("今日のあなたのラッキーナンバーは")
    print(tmp)
    print("です！やったね！")
else:
    # today が偶数を含まなかった場合
    print("あなたは今日一日踏んだり蹴ったりです！m9(^Д^)ﾌﾟｷﾞｬｰ")
```

上記プログラムの実行結果:

```
あなたは今日一日踏んだり蹴ったりです！m9(^Д^)ﾌﾟｷﾞｬｰ
```

### 等値演算子がダメな理由(ちょっと高度な話)
先に、等値演算子`==`による`None`判定がうまくいかない例を挙げよう:

```python
class MyClass:
    def __eq__(self, other):
        """ `==`演算子のオーバーロード """
        return True

my_obj = MyClass()
print(my_obj == None) # True
print(my_obj is None) # False
```

次に、うまくいかない理由を簡潔に説明しよう:

1. `==`演算子はプログラム内で**オーバーロードが可能**である(ユーザー側やライブラリで勝手に定義できる)
1. 1より、ライブラリ等の実装によっては期待通りの値を返さないことがある

さらに詳しく説明しよう。まず、`a == b`という式は、`a.__eq__(b)`の糖衣構文(省略した書き方)である。例えば、上のコード例における

```python
print(my_obj == None)
```

という行は、次の行と等価である:

```python
print(my_obj.__eq__(None))
```

上記のコード例における定義によると、`MyClass`オブジェクトの`__eq__()`メソッドは常に`True`を返す。`my_obj`は`MyClass`クラスのインスタンスであるから、上記の`my_obj.__eq__(None)`という式は当然(しかし当初の期待には反して)`True`を返すというわけである。

上の例の教訓は、(`None`判定のつもりで)`a == None`という式を書いた場合、この式が何を返すかは`a`が属するクラスの作り手に委ねられているということである。もちろん、上の`MyClass`のような酷い実装をすべきでは断じてないが、我々もすべてのクラスが「期待通り」の実装をしてくれていると仮定すべきではない。

ちなみに、`is`演算子だとうまくいく理由は以下のとおり:

1. `is`演算子は**オーバーロードできない**(ユーザー側やライブラリで勝手に定義できない)(これが`==`演算子との最も重要な違い)
1. 1より、`is`演算子を使った時の挙動が決まっている(知らないところで勝手に決められてたりしない)
1. また、`is`演算子による比較はオブジェクトの同一性比較である
1. `None`値はプログラム開始と同時に暗黙に生成される、`None`型の唯一のインスタンスである
1. 3,4より、式`${式1}`が値`None`を返す場合(どちらも同じオブジェクトへの参照なので)`${式1} is None`は必ず`True`になる
1. もちろん、`${式1}`が`None`以外の値を返すなら、(`None`とは異なるオブジェクトへの参照だから)`${式1} is None`は必ず`False`になる

### bool値へのキャストによる判定法について(やっちゃダメ)
次のような判定の仕方もしばしば見られる(何なら筆者も最近までやってた)が、これも良くないのでやめよう:

```python
""" ！！！ 絶対に真似しないでね ！！！ """

if a:
    # a が None だった場合の処理

if not b:
    # b が None でなかった場合の処理
```

理由は、例えば次のような値と`None`値が区別できないからである:

- 整数の`0`
- 空文字列(`""`)
- 空リスト(`[]`)

例:

```python
"""
bool 値へのキャストで None 判定してみる(真似しないでね！！！)
"""

# ！！！ これ使っちゃダメ ！！！
def check_if_None(x: int | str | list[int] | None):
    """ x が None であるか判定(できない) """
    if x:
        print(f"`{x}` は None じゃないです")
    else:
        print(f"`{x}` は None です")

print("[うまく判定できる例]")
check_if_None(None)
check_if_None(2)

print("[判定に失敗する例]")
check_if_None(0)
check_if_None("")
check_if_None([])
```

## クラス定義内で自分自身の名前を使う(Self)
